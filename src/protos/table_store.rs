// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, required, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub access_denied_detail: ::core::option::Option<AccessDeniedDetail>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessDeniedDetail {
    #[prost(string, required, tag = "1")]
    pub auth_action: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub auth_principal_type: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub auth_principal_owner_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub auth_principal_display_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub policy_type: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub no_permission_type: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "7")]
    pub encoded_diagnostic_message: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimaryKeySchema {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "PrimaryKeyType", required, tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "PrimaryKeyOption", optional, tag = "3")]
    pub option: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionRange {
    /// encoded as SQLVariant
    #[prost(bytes = "vec", required, tag = "1")]
    pub begin: ::prost::alloc::vec::Vec<u8>,
    /// encoded as SQLVariant
    #[prost(bytes = "vec", required, tag = "2")]
    pub end: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefinedColumnSchema {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "DefinedColumnType", required, tag = "2")]
    pub r#type: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TableOptions {
    #[prost(int32, optional, tag = "1")]
    pub time_to_live: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub max_versions: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub deviation_cell_version_in_sec: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "6")]
    pub allow_update: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub update_full_row: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexMeta {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub primary_key: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub defined_column: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "IndexUpdateMode", required, tag = "4")]
    pub index_update_mode: i32,
    #[prost(enumeration = "IndexType", required, tag = "5")]
    pub index_type: i32,
    #[prost(enumeration = "IndexSyncPhase", optional, tag = "6")]
    pub index_sync_phase: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableMeta {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub primary_key: ::prost::alloc::vec::Vec<PrimaryKeySchema>,
    #[prost(message, repeated, tag = "3")]
    pub defined_column: ::prost::alloc::vec::Vec<DefinedColumnSchema>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(enumeration = "RowExistenceExpectation", required, tag = "1")]
    pub row_existence: i32,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub column_condition: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CapacityUnit {
    #[prost(int32, optional, tag = "1")]
    pub read: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub write: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CapacityDataSize {
    #[prost(int64, optional, tag = "1")]
    pub read_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub write_size: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservedThroughputDetails {
    #[prost(message, required, tag = "1")]
    pub capacity_unit: CapacityUnit,
    #[prost(int64, required, tag = "2")]
    pub last_increase_time: i64,
    #[prost(int64, optional, tag = "3")]
    pub last_decrease_time: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservedThroughput {
    #[prost(message, required, tag = "1")]
    pub capacity_unit: CapacityUnit,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsumedCapacity {
    #[prost(message, required, tag = "1")]
    pub capacity_unit: CapacityUnit,
    #[prost(message, optional, tag = "2")]
    pub capacity_data_size: ::core::option::Option<CapacityDataSize>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamSpecification {
    #[prost(bool, required, tag = "1")]
    pub enable_stream: bool,
    #[prost(int32, optional, tag = "2")]
    pub expiration_time: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "3")]
    pub columns_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDetails {
    #[prost(bool, required, tag = "1")]
    pub enable_stream: bool,
    #[prost(string, optional, tag = "2")]
    pub stream_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub expiration_time: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub last_enable_time: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "5")]
    pub column_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SseSpecification {
    #[prost(bool, required, tag = "1")]
    pub enable: bool,
    #[prost(enumeration = "SseKeyType", optional, tag = "2")]
    pub key_type: ::core::option::Option<i32>,
    /// only useful when key_type is SSE_BYOK
    #[prost(bytes = "vec", optional, tag = "3")]
    pub key_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// only useful when key_type is SSE_BYOK
    #[prost(bytes = "vec", optional, tag = "4")]
    pub role_arn: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SseDetails {
    #[prost(bool, required, tag = "1")]
    pub enable: bool,
    #[prost(enumeration = "SseKeyType", optional, tag = "2")]
    pub key_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub key_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// only useful when key_type is SSE_BYOK
    #[prost(bytes = "vec", optional, tag = "4")]
    pub role_arn: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTableRequest {
    #[prost(message, required, tag = "1")]
    pub table_meta: TableMeta,
    #[prost(message, required, tag = "2")]
    pub reserved_throughput: ReservedThroughput,
    #[prost(message, optional, tag = "3")]
    pub table_options: ::core::option::Option<TableOptions>,
    #[prost(message, repeated, tag = "4")]
    pub partitions: ::prost::alloc::vec::Vec<PartitionRange>,
    #[prost(message, optional, tag = "5")]
    pub stream_spec: ::core::option::Option<StreamSpecification>,
    #[prost(message, optional, tag = "6")]
    pub sse_spec: ::core::option::Option<SseSpecification>,
    #[prost(message, repeated, tag = "7")]
    pub index_metas: ::prost::alloc::vec::Vec<IndexMeta>,
    #[prost(bool, optional, tag = "8")]
    pub enable_local_txn: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTableResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
    #[prost(string, required, tag = "1")]
    pub main_table_name: ::prost::alloc::string::String,
    #[prost(message, required, tag = "2")]
    pub index_meta: IndexMeta,
    #[prost(bool, optional, tag = "3")]
    pub include_base_data: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateIndexResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropIndexRequest {
    #[prost(string, required, tag = "1")]
    pub main_table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub index_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DropIndexResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDefinedColumnRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<DefinedColumnSchema>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddDefinedColumnResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDefinedColumnRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteDefinedColumnResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub reserved_throughput: ::core::option::Option<ReservedThroughput>,
    #[prost(message, optional, tag = "3")]
    pub table_options: ::core::option::Option<TableOptions>,
    #[prost(message, optional, tag = "4")]
    pub stream_spec: ::core::option::Option<StreamSpecification>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTableResponse {
    #[prost(message, required, tag = "1")]
    pub reserved_throughput_details: ReservedThroughputDetails,
    #[prost(message, required, tag = "2")]
    pub table_options: TableOptions,
    #[prost(message, optional, tag = "3")]
    pub stream_details: ::core::option::Option<StreamDetails>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTableResponse {
    #[prost(message, required, tag = "1")]
    pub table_meta: TableMeta,
    #[prost(message, required, tag = "2")]
    pub reserved_throughput_details: ReservedThroughputDetails,
    #[prost(message, required, tag = "3")]
    pub table_options: TableOptions,
    #[prost(message, optional, tag = "5")]
    pub stream_details: ::core::option::Option<StreamDetails>,
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub shard_splits: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "7")]
    pub sse_details: ::core::option::Option<SseDetails>,
    #[prost(message, repeated, tag = "8")]
    pub index_metas: ::prost::alloc::vec::Vec<IndexMeta>,
    #[prost(int64, optional, tag = "9")]
    pub creation_time: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTableRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTableResponse {
    #[prost(string, repeated, tag = "1")]
    pub table_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTableResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoadTableResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnloadTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnloadTableResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
    #[prost(int64, optional, tag = "1")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub specific_time: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReturnContent {
    #[prost(enumeration = "ReturnType", optional, tag = "1")]
    pub return_type: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub return_column_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub columns_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub time_range: ::core::option::Option<TimeRange>,
    #[prost(int32, optional, tag = "5")]
    pub max_versions: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub filter: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "8")]
    pub start_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub end_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "10")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "11")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRowResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", required, tag = "2")]
    pub row: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub row_change: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, required, tag = "3")]
    pub condition: Condition,
    #[prost(message, optional, tag = "4")]
    pub return_content: ::core::option::Option<ReturnContent>,
    #[prost(string, optional, tag = "5")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRowResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub row: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub row: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, required, tag = "3")]
    pub condition: Condition,
    #[prost(message, optional, tag = "4")]
    pub return_content: ::core::option::Option<ReturnContent>,
    #[prost(string, optional, tag = "5")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRowResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub row: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, required, tag = "3")]
    pub condition: Condition,
    #[prost(message, optional, tag = "4")]
    pub return_content: ::core::option::Option<ReturnContent>,
    #[prost(string, optional, tag = "5")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRowResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub row: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInBatchGetRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub primary_key: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub token: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, repeated, tag = "4")]
    pub columns_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub time_range: ::core::option::Option<TimeRange>,
    #[prost(int32, optional, tag = "6")]
    pub max_versions: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub filter: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "9")]
    pub start_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub end_column: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetRowRequest {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<TableInBatchGetRowRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowInBatchGetRowResponse {
    #[prost(bool, required, tag = "1")]
    pub is_ok: bool,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, optional, tag = "3")]
    pub consumed: ::core::option::Option<ConsumedCapacity>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub row: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInBatchGetRowResponse {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<RowInBatchGetRowResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetRowResponse {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<TableInBatchGetRowResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowInBatchWriteRowRequest {
    #[prost(enumeration = "OperationType", required, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub row_change: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, required, tag = "3")]
    pub condition: Condition,
    #[prost(message, optional, tag = "4")]
    pub return_content: ::core::option::Option<ReturnContent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInBatchWriteRowRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<RowInBatchWriteRowRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRowRequest {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<TableInBatchWriteRowRequest>,
    #[prost(string, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_atomic: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowInBatchWriteRowResponse {
    #[prost(bool, required, tag = "1")]
    pub is_ok: bool,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, optional, tag = "3")]
    pub consumed: ::core::option::Option<ConsumedCapacity>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub row: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInBatchWriteRowResponse {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<RowInBatchWriteRowResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRowResponse {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<TableInBatchWriteRowResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRangeRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(enumeration = "Direction", required, tag = "2")]
    pub direction: i32,
    #[prost(string, repeated, tag = "3")]
    pub columns_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub time_range: ::core::option::Option<TimeRange>,
    #[prost(int32, optional, tag = "5")]
    pub max_versions: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub limit: ::core::option::Option<i32>,
    #[prost(bytes = "vec", required, tag = "7")]
    pub inclusive_start_primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", required, tag = "8")]
    pub exclusive_end_primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "10")]
    pub filter: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "11")]
    pub start_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub end_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "13")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "14")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRangeResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", required, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub next_start_primary_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartLocalTransactionRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartLocalTransactionResponse {
    #[prost(string, required, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitTransactionRequest {
    #[prost(string, required, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitTransactionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbortTransactionRequest {
    #[prost(string, required, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbortTransactionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStreamRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stream {
    #[prost(string, required, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "3")]
    pub creation_time: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStreamResponse {
    #[prost(message, repeated, tag = "1")]
    pub streams: ::prost::alloc::vec::Vec<Stream>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamShard {
    #[prost(string, required, tag = "1")]
    pub shard_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub parent_sibling_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeStreamRequest {
    #[prost(string, required, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub inclusive_start_shard_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub shard_limit: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub support_timeseries_data_table: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeStreamResponse {
    #[prost(string, required, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub expiration_time: i32,
    #[prost(string, required, tag = "3")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "4")]
    pub creation_time: i64,
    #[prost(enumeration = "StreamStatus", required, tag = "5")]
    pub stream_status: i32,
    #[prost(message, repeated, tag = "6")]
    pub shards: ::prost::alloc::vec::Vec<StreamShard>,
    #[prost(string, optional, tag = "7")]
    pub next_shard_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "8")]
    pub is_timeseries_data_table: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShardIteratorRequest {
    #[prost(string, required, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub shard_id: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "3")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "4")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShardIteratorResponse {
    #[prost(string, required, tag = "1")]
    pub shard_iterator: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub next_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStreamRecordRequest {
    #[prost(string, required, tag = "1")]
    pub shard_iterator: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2")]
    pub limit: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStreamRecordResponse {
    #[prost(message, repeated, tag = "1")]
    pub stream_records: ::prost::alloc::vec::Vec<
        get_stream_record_response::StreamRecord,
    >,
    #[prost(string, optional, tag = "2")]
    pub next_shard_iterator: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub consumed: ::core::option::Option<ConsumedCapacity>,
    #[prost(bool, optional, tag = "4")]
    pub may_more_record: ::core::option::Option<bool>,
}
/// Nested message and enum types in `GetStreamRecordResponse`.
pub mod get_stream_record_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamRecord {
        #[prost(enumeration = "super::ActionType", required, tag = "1")]
        pub action_type: i32,
        #[prost(bytes = "vec", required, tag = "2")]
        pub record: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub origin_record: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeSplitPointsBySizeRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    /// in 100MB
    #[prost(int64, required, tag = "2")]
    pub split_size: i64,
    #[prost(int64, optional, tag = "3")]
    pub split_size_unit_in_byte: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub split_point_limit: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeSplitPointsBySizeResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(message, repeated, tag = "2")]
    pub schema: ::prost::alloc::vec::Vec<PrimaryKeySchema>,
    /// *
    /// Split points between splits, in the increasing order
    ///
    /// A split is a consecutive range of primary keys,
    /// whose data size is about split_size specified in the request.
    /// The size could be hard to be precise.
    ///
    /// A split point is an array of primary-key column w.r.t. table schema,
    /// which is never longer than that of table schema.
    /// Tailing -inf will be omitted to reduce transmission payloads.
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub split_points: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "4")]
    pub locations: ::prost::alloc::vec::Vec<
        compute_split_points_by_size_response::SplitLocation,
    >,
}
/// Nested message and enum types in `ComputeSplitPointsBySizeResponse`.
pub mod compute_split_points_by_size_response {
    /// *
    /// Locations where splits lies in.
    ///
    /// By the managed nature of TableStore, these locations are no more than hints.
    /// If a location is not suitable to be seen, an empty string will be placed.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SplitLocation {
        #[prost(string, required, tag = "1")]
        pub location: ::prost::alloc::string::String,
        #[prost(sint64, required, tag = "2")]
        pub repeat: i64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkExportRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub columns_to_get: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", required, tag = "3")]
    pub inclusive_start_primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", required, tag = "4")]
    pub exclusive_end_primary_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub filter: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(
        enumeration = "DataBlockType",
        optional,
        tag = "6",
        default = "DbtSimpleRowMatrix"
    )]
    pub data_block_type_hint: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkExportResponse {
    #[prost(message, required, tag = "1")]
    pub consumed: ConsumedCapacity,
    #[prost(bytes = "vec", required, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub next_start_primary_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "DataBlockType", optional, tag = "4")]
    pub data_block_type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkImportRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<RowInBulkImportRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowInBulkImportRequest {
    #[prost(enumeration = "OperationType", required, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub row_change: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkImportResponse {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<RowInBulkImportResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowInBulkImportResponse {
    #[prost(bool, required, tag = "1")]
    pub is_ok: bool,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, optional, tag = "3")]
    pub consumed: ::core::option::Option<ConsumedCapacity>,
}
/// computeSplits
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeSplitsRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub search_index_splits_options: ::core::option::Option<SearchIndexSplitsOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchIndexSplitsOptions {
    #[prost(string, optional, tag = "1")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeSplitsResponse {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "2")]
    pub splits_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlQueryRequest {
    #[prost(string, required, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(enumeration = "SqlPayloadVersion", optional, tag = "2")]
    pub version: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub sql_version: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "5")]
    pub search_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableConsumedCapacity {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub consumed: ::core::option::Option<ConsumedCapacity>,
    #[prost(message, optional, tag = "3")]
    pub reserved_throughput: ::core::option::Option<ReservedThroughput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub consumes: ::prost::alloc::vec::Vec<TableConsumedCapacity>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub rows: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "SqlPayloadVersion", optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    #[prost(enumeration = "SqlStatementType", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "8")]
    pub next_search_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrimaryKeyType {
    Integer = 1,
    String = 2,
    Binary = 3,
}
impl PrimaryKeyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Integer => "INTEGER",
            Self::String => "STRING",
            Self::Binary => "BINARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTEGER" => Some(Self::Integer),
            "STRING" => Some(Self::String),
            "BINARY" => Some(Self::Binary),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DefinedColumnType {
    DctInteger = 1,
    DctDouble = 2,
    DctBoolean = 3,
    DctString = 4,
    DctBlob = 7,
}
impl DefinedColumnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DctInteger => "DCT_INTEGER",
            Self::DctDouble => "DCT_DOUBLE",
            Self::DctBoolean => "DCT_BOOLEAN",
            Self::DctString => "DCT_STRING",
            Self::DctBlob => "DCT_BLOB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DCT_INTEGER" => Some(Self::DctInteger),
            "DCT_DOUBLE" => Some(Self::DctDouble),
            "DCT_BOOLEAN" => Some(Self::DctBoolean),
            "DCT_STRING" => Some(Self::DctString),
            "DCT_BLOB" => Some(Self::DctBlob),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrimaryKeyOption {
    AutoIncrement = 1,
}
impl PrimaryKeyOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AutoIncrement => "AUTO_INCREMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTO_INCREMENT" => Some(Self::AutoIncrement),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexUpdateMode {
    IumAsyncIndex = 0,
    IumSyncIndex = 1,
}
impl IndexUpdateMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::IumAsyncIndex => "IUM_ASYNC_INDEX",
            Self::IumSyncIndex => "IUM_SYNC_INDEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IUM_ASYNC_INDEX" => Some(Self::IumAsyncIndex),
            "IUM_SYNC_INDEX" => Some(Self::IumSyncIndex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexType {
    ItGlobalIndex = 0,
    ItLocalIndex = 1,
}
impl IndexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ItGlobalIndex => "IT_GLOBAL_INDEX",
            Self::ItLocalIndex => "IT_LOCAL_INDEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IT_GLOBAL_INDEX" => Some(Self::ItGlobalIndex),
            "IT_LOCAL_INDEX" => Some(Self::ItLocalIndex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexSyncPhase {
    IspInvalid = 0,
    IspFull = 1,
    IspIncr = 2,
}
impl IndexSyncPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::IspInvalid => "ISP_INVALID",
            Self::IspFull => "ISP_FULL",
            Self::IspIncr => "ISP_INCR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISP_INVALID" => Some(Self::IspInvalid),
            "ISP_FULL" => Some(Self::IspFull),
            "ISP_INCR" => Some(Self::IspIncr),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowExistenceExpectation {
    Ignore = 0,
    ExpectExist = 1,
    ExpectNotExist = 2,
}
impl RowExistenceExpectation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ignore => "IGNORE",
            Self::ExpectExist => "EXPECT_EXIST",
            Self::ExpectNotExist => "EXPECT_NOT_EXIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IGNORE" => Some(Self::Ignore),
            "EXPECT_EXIST" => Some(Self::ExpectExist),
            "EXPECT_NOT_EXIST" => Some(Self::ExpectNotExist),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SseKeyType {
    SseKmsService = 1,
    SseByok = 2,
}
impl SseKeyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SseKmsService => "SSE_KMS_SERVICE",
            Self::SseByok => "SSE_BYOK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SSE_KMS_SERVICE" => Some(Self::SseKmsService),
            "SSE_BYOK" => Some(Self::SseByok),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReturnType {
    RtNone = 0,
    RtPk = 1,
    RtAfterModify = 2,
}
impl ReturnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RtNone => "RT_NONE",
            Self::RtPk => "RT_PK",
            Self::RtAfterModify => "RT_AFTER_MODIFY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RT_NONE" => Some(Self::RtNone),
            "RT_PK" => Some(Self::RtPk),
            "RT_AFTER_MODIFY" => Some(Self::RtAfterModify),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
    Put = 1,
    Update = 2,
    Delete = 3,
}
impl OperationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Put => "PUT",
            Self::Update => "UPDATE",
            Self::Delete => "DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUT" => Some(Self::Put),
            "UPDATE" => Some(Self::Update),
            "DELETE" => Some(Self::Delete),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Forward = 0,
    Backward = 1,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Forward => "FORWARD",
            Self::Backward => "BACKWARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FORWARD" => Some(Self::Forward),
            "BACKWARD" => Some(Self::Backward),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamStatus {
    StreamEnabling = 1,
    StreamActive = 2,
}
impl StreamStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StreamEnabling => "STREAM_ENABLING",
            Self::StreamActive => "STREAM_ACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_ENABLING" => Some(Self::StreamEnabling),
            "STREAM_ACTIVE" => Some(Self::StreamActive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionType {
    PutRow = 1,
    UpdateRow = 2,
    DeleteRow = 3,
}
impl ActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PutRow => "PUT_ROW",
            Self::UpdateRow => "UPDATE_ROW",
            Self::DeleteRow => "DELETE_ROW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUT_ROW" => Some(Self::PutRow),
            "UPDATE_ROW" => Some(Self::UpdateRow),
            "DELETE_ROW" => Some(Self::DeleteRow),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataBlockType {
    DbtPlainBuffer = 0,
    DbtSimpleRowMatrix = 1,
}
impl DataBlockType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DbtPlainBuffer => "DBT_PLAIN_BUFFER",
            Self::DbtSimpleRowMatrix => "DBT_SIMPLE_ROW_MATRIX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DBT_PLAIN_BUFFER" => Some(Self::DbtPlainBuffer),
            "DBT_SIMPLE_ROW_MATRIX" => Some(Self::DbtSimpleRowMatrix),
            _ => None,
        }
    }
}
/// SQLQuery
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlPayloadVersion {
    SqlPlainBuffer = 1,
    SqlFlatBuffers = 2,
}
impl SqlPayloadVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SqlPlainBuffer => "SQL_PLAIN_BUFFER",
            Self::SqlFlatBuffers => "SQL_FLAT_BUFFERS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_PLAIN_BUFFER" => Some(Self::SqlPlainBuffer),
            "SQL_FLAT_BUFFERS" => Some(Self::SqlFlatBuffers),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlStatementType {
    SqlSelect = 1,
    SqlCreateTable = 2,
    SqlShowTable = 3,
    SqlDescribeTable = 4,
    SqlDropTable = 5,
    SqlAlterTable = 6,
}
impl SqlStatementType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SqlSelect => "SQL_SELECT",
            Self::SqlCreateTable => "SQL_CREATE_TABLE",
            Self::SqlShowTable => "SQL_SHOW_TABLE",
            Self::SqlDescribeTable => "SQL_DESCRIBE_TABLE",
            Self::SqlDropTable => "SQL_DROP_TABLE",
            Self::SqlAlterTable => "SQL_ALTER_TABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_SELECT" => Some(Self::SqlSelect),
            "SQL_CREATE_TABLE" => Some(Self::SqlCreateTable),
            "SQL_SHOW_TABLE" => Some(Self::SqlShowTable),
            "SQL_DESCRIBE_TABLE" => Some(Self::SqlDescribeTable),
            "SQL_DROP_TABLE" => Some(Self::SqlDropTable),
            "SQL_ALTER_TABLE" => Some(Self::SqlAlterTable),
            _ => None,
        }
    }
}
