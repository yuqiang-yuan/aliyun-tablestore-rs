// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod fbs {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[allow(clippy::missing_safety_doc)]
    #[allow(unused_imports, dead_code)]
    pub mod timeseries {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
        pub const ENUM_MIN_DATA_TYPE: i8 = 0;
        #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
        pub const ENUM_MAX_DATA_TYPE: i8 = 5;
        #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_DATA_TYPE: [DataType; 6] = [
            DataType::NONE,
            DataType::LONG,
            DataType::BOOLEAN,
            DataType::DOUBLE,
            DataType::STRING,
            DataType::BINARY,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct DataType(pub i8);
        #[allow(non_upper_case_globals)]
        impl DataType {
            pub const NONE: Self = Self(0);
            pub const LONG: Self = Self(1);
            pub const BOOLEAN: Self = Self(2);
            pub const DOUBLE: Self = Self(3);
            pub const STRING: Self = Self(4);
            pub const BINARY: Self = Self(5);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::LONG, Self::BOOLEAN, Self::DOUBLE, Self::STRING, Self::BINARY];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::LONG => Some("LONG"),
                    Self::BOOLEAN => Some("BOOLEAN"),
                    Self::DOUBLE => Some("DOUBLE"),
                    Self::STRING => Some("STRING"),
                    Self::BINARY => Some("BINARY"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for DataType {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for DataType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for DataType {
            type Output = DataType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<i8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for DataType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl flatbuffers::Verifiable for DataType {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for DataType {}
        pub enum BytesValueOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BytesValue<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BytesValue<'a> {
            type Inner = BytesValue<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> BytesValue<'a> {
            pub const VT_VALUE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BytesValue { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args BytesValueArgs<'args>,
            ) -> flatbuffers::WIPOffset<BytesValue<'bldr>> {
                let mut builder = BytesValueBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn value(&self) -> Option<flatbuffers::Vector<'a, i8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(BytesValue::VT_VALUE, None)
                }
            }
        }

        impl flatbuffers::Verifiable for BytesValue<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("value", Self::VT_VALUE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BytesValueArgs<'a> {
            pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
        }
        impl Default for BytesValueArgs<'_> {
            #[inline]
            fn default() -> Self {
                BytesValueArgs { value: None }
            }
        }

        pub struct BytesValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BytesValueBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BytesValue::VT_VALUE, value);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BytesValueBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                BytesValueBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BytesValue<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BytesValue<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BytesValue");
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum FieldValuesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FieldValues<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FieldValues<'a> {
            type Inner = FieldValues<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> FieldValues<'a> {
            pub const VT_LONG_VALUES: flatbuffers::VOffsetT = 4;
            pub const VT_BOOL_VALUES: flatbuffers::VOffsetT = 6;
            pub const VT_DOUBLE_VALUES: flatbuffers::VOffsetT = 8;
            pub const VT_STRING_VALUES: flatbuffers::VOffsetT = 10;
            pub const VT_BINARY_VALUES: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FieldValues { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FieldValuesArgs<'args>,
            ) -> flatbuffers::WIPOffset<FieldValues<'bldr>> {
                let mut builder = FieldValuesBuilder::new(_fbb);
                if let Some(x) = args.binary_values {
                    builder.add_binary_values(x);
                }
                if let Some(x) = args.string_values {
                    builder.add_string_values(x);
                }
                if let Some(x) = args.double_values {
                    builder.add_double_values(x);
                }
                if let Some(x) = args.bool_values {
                    builder.add_bool_values(x);
                }
                if let Some(x) = args.long_values {
                    builder.add_long_values(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn long_values(&self) -> Option<flatbuffers::Vector<'a, i64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(FieldValues::VT_LONG_VALUES, None)
                }
            }
            #[inline]
            pub fn bool_values(&self) -> Option<flatbuffers::Vector<'a, bool>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(FieldValues::VT_BOOL_VALUES, None)
                }
            }
            #[inline]
            pub fn double_values(&self) -> Option<flatbuffers::Vector<'a, f64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(FieldValues::VT_DOUBLE_VALUES, None)
                }
            }
            #[inline]
            pub fn string_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(
                            FieldValues::VT_STRING_VALUES,
                            None,
                        )
                }
            }
            #[inline]
            pub fn binary_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue<'a>>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue>>>>(
                            FieldValues::VT_BINARY_VALUES,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for FieldValues<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("long_values", Self::VT_LONG_VALUES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("bool_values", Self::VT_BOOL_VALUES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("double_values", Self::VT_DOUBLE_VALUES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(
                        "string_values",
                        Self::VT_STRING_VALUES,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BytesValue>>>>(
                        "binary_values",
                        Self::VT_BINARY_VALUES,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct FieldValuesArgs<'a> {
            pub long_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
            pub bool_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
            pub double_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
            pub string_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
            pub binary_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue<'a>>>>>,
        }
        impl Default for FieldValuesArgs<'_> {
            #[inline]
            fn default() -> Self {
                FieldValuesArgs {
                    long_values: None,
                    bool_values: None,
                    double_values: None,
                    string_values: None,
                    binary_values: None,
                }
            }
        }

        pub struct FieldValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FieldValuesBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_long_values(&mut self, long_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldValues::VT_LONG_VALUES, long_values);
            }
            #[inline]
            pub fn add_bool_values(&mut self, bool_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, bool>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldValues::VT_BOOL_VALUES, bool_values);
            }
            #[inline]
            pub fn add_double_values(&mut self, double_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldValues::VT_DOUBLE_VALUES, double_values);
            }
            #[inline]
            pub fn add_string_values(&mut self, string_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldValues::VT_STRING_VALUES, string_values);
            }
            #[inline]
            pub fn add_binary_values(&mut self, binary_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BytesValue<'b>>>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldValues::VT_BINARY_VALUES, binary_values);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FieldValuesBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FieldValuesBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FieldValues<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FieldValues<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FieldValues");
                ds.field("long_values", &self.long_values());
                ds.field("bool_values", &self.bool_values());
                ds.field("double_values", &self.double_values());
                ds.field("string_values", &self.string_values());
                ds.field("binary_values", &self.binary_values());
                ds.finish()
            }
        }
        pub enum TagOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Tag<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
            type Inner = Tag<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> Tag<'a> {
            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Tag { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TagArgs<'args>,
            ) -> flatbuffers::WIPOffset<Tag<'bldr>> {
                let mut builder = TagBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_NAME, None) }
            }
            #[inline]
            pub fn value(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_VALUE, None) }
            }
        }

        impl flatbuffers::Verifiable for Tag<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TagArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl Default for TagArgs<'_> {
            #[inline]
            fn default() -> Self {
                TagArgs { name: None, value: None }
            }
        }

        pub struct TagBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TagBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_NAME, name);
            }
            #[inline]
            pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_VALUE, value);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TagBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TagBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Tag<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Tag");
                ds.field("name", &self.name());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum FlatBufferRowInGroupOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FlatBufferRowInGroup<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FlatBufferRowInGroup<'a> {
            type Inner = FlatBufferRowInGroup<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> FlatBufferRowInGroup<'a> {
            pub const VT_DATA_SOURCE: flatbuffers::VOffsetT = 4;
            pub const VT_TAGS: flatbuffers::VOffsetT = 6;
            pub const VT_TIME: flatbuffers::VOffsetT = 8;
            pub const VT_FIELD_VALUES: flatbuffers::VOffsetT = 10;
            pub const VT_META_CACHE_UPDATE_TIME: flatbuffers::VOffsetT = 12;
            pub const VT_TAG_LIST: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FlatBufferRowInGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FlatBufferRowInGroupArgs<'args>,
            ) -> flatbuffers::WIPOffset<FlatBufferRowInGroup<'bldr>> {
                let mut builder = FlatBufferRowInGroupBuilder::new(_fbb);
                builder.add_time(args.time);
                if let Some(x) = args.tag_list {
                    builder.add_tag_list(x);
                }
                builder.add_meta_cache_update_time(args.meta_cache_update_time);
                if let Some(x) = args.field_values {
                    builder.add_field_values(x);
                }
                if let Some(x) = args.tags {
                    builder.add_tags(x);
                }
                if let Some(x) = args.data_source {
                    builder.add_data_source(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn data_source(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlatBufferRowInGroup::VT_DATA_SOURCE, None) }
            }
            #[inline]
            pub fn tags(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlatBufferRowInGroup::VT_TAGS, None) }
            }
            #[inline]
            pub fn time(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i64>(FlatBufferRowInGroup::VT_TIME, Some(0)).unwrap() }
            }
            #[inline]
            pub fn field_values(&self) -> Option<FieldValues<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<FieldValues>>(FlatBufferRowInGroup::VT_FIELD_VALUES, None)
                }
            }
            #[inline]
            pub fn meta_cache_update_time(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(FlatBufferRowInGroup::VT_META_CACHE_UPDATE_TIME, Some(0)).unwrap() }
            }
            #[inline]
            pub fn tag_list(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag>>>>(
                            FlatBufferRowInGroup::VT_TAG_LIST,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for FlatBufferRowInGroup<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data_source", Self::VT_DATA_SOURCE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tags", Self::VT_TAGS, false)?
                    .visit_field::<i64>("time", Self::VT_TIME, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<FieldValues>>("field_values", Self::VT_FIELD_VALUES, false)?
                    .visit_field::<u32>("meta_cache_update_time", Self::VT_META_CACHE_UPDATE_TIME, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tag>>>>(
                        "tag_list",
                        Self::VT_TAG_LIST,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct FlatBufferRowInGroupArgs<'a> {
            pub data_source: Option<flatbuffers::WIPOffset<&'a str>>,
            pub tags: Option<flatbuffers::WIPOffset<&'a str>>,
            pub time: i64,
            pub field_values: Option<flatbuffers::WIPOffset<FieldValues<'a>>>,
            pub meta_cache_update_time: u32,
            pub tag_list: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>>>,
        }
        impl Default for FlatBufferRowInGroupArgs<'_> {
            #[inline]
            fn default() -> Self {
                FlatBufferRowInGroupArgs {
                    data_source: None,
                    tags: None,
                    time: 0,
                    field_values: None,
                    meta_cache_update_time: 0,
                    tag_list: None,
                }
            }
        }

        pub struct FlatBufferRowInGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlatBufferRowInGroupBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_data_source(&mut self, data_source: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowInGroup::VT_DATA_SOURCE, data_source);
            }
            #[inline]
            pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowInGroup::VT_TAGS, tags);
            }
            #[inline]
            pub fn add_time(&mut self, time: i64) {
                self.fbb_.push_slot::<i64>(FlatBufferRowInGroup::VT_TIME, time, 0);
            }
            #[inline]
            pub fn add_field_values(&mut self, field_values: flatbuffers::WIPOffset<FieldValues<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<FieldValues>>(FlatBufferRowInGroup::VT_FIELD_VALUES, field_values);
            }
            #[inline]
            pub fn add_meta_cache_update_time(&mut self, meta_cache_update_time: u32) {
                self.fbb_
                    .push_slot::<u32>(FlatBufferRowInGroup::VT_META_CACHE_UPDATE_TIME, meta_cache_update_time, 0);
            }
            #[inline]
            pub fn add_tag_list(&mut self, tag_list: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Tag<'b>>>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowInGroup::VT_TAG_LIST, tag_list);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlatBufferRowInGroupBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FlatBufferRowInGroupBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FlatBufferRowInGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FlatBufferRowInGroup<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FlatBufferRowInGroup");
                ds.field("data_source", &self.data_source());
                ds.field("tags", &self.tags());
                ds.field("time", &self.time());
                ds.field("field_values", &self.field_values());
                ds.field("meta_cache_update_time", &self.meta_cache_update_time());
                ds.field("tag_list", &self.tag_list());
                ds.finish()
            }
        }
        pub enum FlatBufferRowGroupOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FlatBufferRowGroup<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FlatBufferRowGroup<'a> {
            type Inner = FlatBufferRowGroup<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> FlatBufferRowGroup<'a> {
            pub const VT_MEASUREMENT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_FIELD_NAMES: flatbuffers::VOffsetT = 6;
            pub const VT_FIELD_TYPES: flatbuffers::VOffsetT = 8;
            pub const VT_ROWS: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FlatBufferRowGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FlatBufferRowGroupArgs<'args>,
            ) -> flatbuffers::WIPOffset<FlatBufferRowGroup<'bldr>> {
                let mut builder = FlatBufferRowGroupBuilder::new(_fbb);
                if let Some(x) = args.rows {
                    builder.add_rows(x);
                }
                if let Some(x) = args.field_types {
                    builder.add_field_types(x);
                }
                if let Some(x) = args.field_names {
                    builder.add_field_names(x);
                }
                if let Some(x) = args.measurement_name {
                    builder.add_measurement_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn measurement_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(FlatBufferRowGroup::VT_MEASUREMENT_NAME, None)
                }
            }
            #[inline]
            pub fn field_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(
                            FlatBufferRowGroup::VT_FIELD_NAMES,
                            None,
                        )
                }
            }
            #[inline]
            pub fn field_types(&self) -> Option<flatbuffers::Vector<'a, DataType>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, DataType>>>(FlatBufferRowGroup::VT_FIELD_TYPES, None)
                }
            }
            #[inline]
            pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowInGroup<'a>>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowInGroup>>>>(
                            FlatBufferRowGroup::VT_ROWS,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for FlatBufferRowGroup<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("measurement_name", Self::VT_MEASUREMENT_NAME, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(
                        "field_names",
                        Self::VT_FIELD_NAMES,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, DataType>>>("field_types", Self::VT_FIELD_TYPES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FlatBufferRowInGroup>>>>(
                        "rows",
                        Self::VT_ROWS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct FlatBufferRowGroupArgs<'a> {
            pub measurement_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub field_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
            pub field_types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, DataType>>>,
            pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowInGroup<'a>>>>>,
        }
        impl Default for FlatBufferRowGroupArgs<'_> {
            #[inline]
            fn default() -> Self {
                FlatBufferRowGroupArgs {
                    measurement_name: None,
                    field_names: None,
                    field_types: None,
                    rows: None,
                }
            }
        }

        pub struct FlatBufferRowGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlatBufferRowGroupBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_measurement_name(&mut self, measurement_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowGroup::VT_MEASUREMENT_NAME, measurement_name);
            }
            #[inline]
            pub fn add_field_names(&mut self, field_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowGroup::VT_FIELD_NAMES, field_names);
            }
            #[inline]
            pub fn add_field_types(&mut self, field_types: flatbuffers::WIPOffset<flatbuffers::Vector<'b, DataType>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowGroup::VT_FIELD_TYPES, field_types);
            }
            #[inline]
            pub fn add_rows(&mut self, rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FlatBufferRowInGroup<'b>>>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRowGroup::VT_ROWS, rows);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlatBufferRowGroupBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FlatBufferRowGroupBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FlatBufferRowGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FlatBufferRowGroup<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FlatBufferRowGroup");
                ds.field("measurement_name", &self.measurement_name());
                ds.field("field_names", &self.field_names());
                ds.field("field_types", &self.field_types());
                ds.field("rows", &self.rows());
                ds.finish()
            }
        }
        pub enum FlatBufferRowsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FlatBufferRows<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FlatBufferRows<'a> {
            type Inner = FlatBufferRows<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> FlatBufferRows<'a> {
            pub const VT_ROW_GROUPS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FlatBufferRows { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FlatBufferRowsArgs<'args>,
            ) -> flatbuffers::WIPOffset<FlatBufferRows<'bldr>> {
                let mut builder = FlatBufferRowsBuilder::new(_fbb);
                if let Some(x) = args.row_groups {
                    builder.add_row_groups(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn row_groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowGroup<'a>>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowGroup>>>>(
                            FlatBufferRows::VT_ROW_GROUPS,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for FlatBufferRows<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FlatBufferRowGroup>>>>(
                        "row_groups",
                        Self::VT_ROW_GROUPS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct FlatBufferRowsArgs<'a> {
            pub row_groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FlatBufferRowGroup<'a>>>>>,
        }
        impl Default for FlatBufferRowsArgs<'_> {
            #[inline]
            fn default() -> Self {
                FlatBufferRowsArgs { row_groups: None }
            }
        }

        pub struct FlatBufferRowsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlatBufferRowsBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_row_groups(
                &mut self,
                row_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FlatBufferRowGroup<'b>>>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FlatBufferRows::VT_ROW_GROUPS, row_groups);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlatBufferRowsBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FlatBufferRowsBuilder { fbb_: _fbb, start_: start }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FlatBufferRows<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FlatBufferRows<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FlatBufferRows");
                ds.field("row_groups", &self.row_groups());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `FlatBufferRows`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_flat_buffer_rows_unchecked`.
        pub fn root_as_flat_buffer_rows(buf: &[u8]) -> Result<FlatBufferRows, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<FlatBufferRows>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `FlatBufferRows` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_flat_buffer_rows_unchecked`.
        pub fn size_prefixed_root_as_flat_buffer_rows(buf: &[u8]) -> Result<FlatBufferRows, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<FlatBufferRows>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `FlatBufferRows` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_flat_buffer_rows_unchecked`.
        pub fn root_as_flat_buffer_rows_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<FlatBufferRows<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<FlatBufferRows<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `FlatBufferRows` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_flat_buffer_rows_unchecked`.
        pub fn size_prefixed_root_as_flat_buffer_rows_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<FlatBufferRows<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<FlatBufferRows<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a FlatBufferRows and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `FlatBufferRows`.
        pub unsafe fn root_as_flat_buffer_rows_unchecked(buf: &[u8]) -> FlatBufferRows {
            unsafe { flatbuffers::root_unchecked::<FlatBufferRows>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed FlatBufferRows and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `FlatBufferRows`.
        pub unsafe fn size_prefixed_root_as_flat_buffer_rows_unchecked(buf: &[u8]) -> FlatBufferRows {
            unsafe { flatbuffers::size_prefixed_root_unchecked::<FlatBufferRows>(buf) }
        }
        #[inline]
        pub fn finish_flat_buffer_rows_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<FlatBufferRows<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_flat_buffer_rows_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<FlatBufferRows<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod timeseries
} // pub mod fbs
