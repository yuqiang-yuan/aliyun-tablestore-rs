// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvgAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardinalityAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaxAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermsAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub agg: ::core::option::Option<Agg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterAgg {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<Query>,
    #[prost(message, optional, tag = "2")]
    pub agg: ::core::option::Option<Agg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedPath {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedAgg {
    #[prost(message, optional, tag = "1")]
    pub nested_path: ::core::option::Option<NestedPath>,
    #[prost(message, optional, tag = "2")]
    pub agg: ::core::option::Option<Agg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoBoundsAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub wrap_longitude: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoDistanceAggRange {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "2")]
    pub range_from: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub range_to: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoDistanceAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub origin: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub ranges: ::prost::alloc::vec::Vec<GeoDistanceAggRange>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// variant
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendedStatsAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// variant
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentilesAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub percents: ::prost::alloc::vec::Vec<f64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentileRanksAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub values: ::prost::alloc::vec::Vec<f64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueCountAgg {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggClause {
    #[prost(string, optional, tag = "1")]
    pub agg_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "AggType", optional, tag = "2")]
    pub agg_type: ::core::option::Option<i32>,
    /// encode by protobuf
    #[prost(bytes = "vec", optional, tag = "3")]
    pub agg_body: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Agg {
    #[prost(message, repeated, tag = "1")]
    pub agg_clause: ::prost::alloc::vec::Vec<AggClause>,
}
/// result
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvgAggResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxAggResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinAggResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumAggResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CardinalityAggResult {
    #[prost(int64, optional, tag = "1")]
    pub value: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bucket {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub doc_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub agg_result: ::core::option::Option<AggResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermsAggResult {
    #[prost(int64, optional, tag = "1")]
    pub doc_count_error_upper_bound: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub sum_of_other_doc_count: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "3")]
    pub bucket: ::prost::alloc::vec::Vec<Bucket>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterAggResult {
    #[prost(int64, optional, tag = "1")]
    pub doc_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub agg_result: ::core::option::Option<AggResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedAggResult {
    #[prost(int64, optional, tag = "1")]
    pub doc_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub agg_result: ::core::option::Option<AggResult>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoPoint {
    #[prost(double, optional, tag = "1")]
    pub lat: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub lon: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoBoundsAggResult {
    #[prost(message, optional, tag = "1")]
    pub top_left: ::core::option::Option<GeoPoint>,
    #[prost(message, optional, tag = "2")]
    pub bottom_right: ::core::option::Option<GeoPoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeBucket {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "2")]
    pub range_from: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub range_to: ::core::option::Option<f64>,
    #[prost(int64, optional, tag = "4")]
    pub doc_count: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoDistanceAggResult {
    #[prost(message, repeated, tag = "1")]
    pub bucket: ::prost::alloc::vec::Vec<RangeBucket>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatsAggResult {
    #[prost(int64, optional, tag = "1")]
    pub count: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "2")]
    pub min: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub max: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "4")]
    pub avg: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "5")]
    pub sum: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtendedStatsAggResult {
    #[prost(int64, optional, tag = "1")]
    pub count: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "2")]
    pub min: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub max: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "4")]
    pub avg: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "5")]
    pub sum: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub sum_of_squares: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "7")]
    pub variance: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "8")]
    pub std_deviation: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "9")]
    pub std_deviation_bounds_upper: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "10")]
    pub std_deviation_bounds_lower: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Percentile {
    #[prost(double, optional, tag = "1")]
    pub percent: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentilesAggResult {
    #[prost(message, repeated, tag = "1")]
    pub percentiles: ::prost::alloc::vec::Vec<Percentile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentileRanksAggResult {
    #[prost(message, repeated, tag = "1")]
    pub percentiles: ::prost::alloc::vec::Vec<Percentile>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueCountAggResult {
    #[prost(int64, optional, tag = "1")]
    pub count: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubAggResult {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "AggType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    /// encode XXAggResult
    #[prost(bytes = "vec", optional, tag = "3")]
    pub agg_result: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggResult {
    #[prost(message, repeated, tag = "1")]
    pub sub_agg_results: ::prost::alloc::vec::Vec<SubAggResult>,
}
/// agg & group by
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggregation {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "AggregationType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub body: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggregations {
    #[prost(message, repeated, tag = "1")]
    pub aggs: ::prost::alloc::vec::Vec<Aggregation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBy {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "GroupByType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub body: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBys {
    #[prost(message, repeated, tag = "1")]
    pub group_bys: ::prost::alloc::vec::Vec<GroupBy>,
}
/// single agg
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvgAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// encoded as SQLVariant, check in SearchProxy
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaxAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctCountAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopRowsAggregation {
    #[prost(int32, optional, tag = "1")]
    pub limit: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub sort: ::core::option::Option<Sort>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentilesAggregation {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub percentiles: ::prost::alloc::vec::Vec<f64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// group agg
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldRange {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub min: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub max: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByDateHistogram {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub interval: ::core::option::Option<DateTimeValue>,
    #[prost(message, optional, tag = "3")]
    pub field_range: ::core::option::Option<FieldRange>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "5")]
    pub min_doc_count: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub time_zone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub sort: ::core::option::Option<GroupBySort>,
    #[prost(message, optional, tag = "8")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "9")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
    #[prost(message, optional, tag = "10")]
    pub offset: ::core::option::Option<DateTimeValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByHistogram {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub interval: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub missing: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "4")]
    pub min_doc_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub sort: ::core::option::Option<GroupBySort>,
    #[prost(message, optional, tag = "6")]
    pub field_range: ::core::option::Option<FieldRange>,
    #[prost(message, optional, tag = "7")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "8")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
    #[prost(bytes = "vec", optional, tag = "9")]
    pub offset: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupKeySort {
    #[prost(enumeration = "SortOrder", optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RowCountSort {
    #[prost(enumeration = "SortOrder", optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubAggSort {
    #[prost(string, optional, tag = "1")]
    pub sub_agg_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "SortOrder", optional, tag = "2")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBySorter {
    #[prost(message, optional, tag = "1")]
    pub group_key_sort: ::core::option::Option<GroupKeySort>,
    #[prost(message, optional, tag = "2")]
    pub row_count_sort: ::core::option::Option<RowCountSort>,
    #[prost(message, optional, tag = "3")]
    pub sub_agg_sort: ::core::option::Option<SubAggSort>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBySort {
    #[prost(message, repeated, tag = "1")]
    pub sorters: ::prost::alloc::vec::Vec<GroupBySorter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByComposite {
    #[prost(message, optional, tag = "1")]
    pub sources: ::core::option::Option<GroupBys>,
    #[prost(int32, optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
    #[prost(string, optional, tag = "6")]
    pub next_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub suggested_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByCompositeResultItem {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, repeated, packed = "false", tag = "5")]
    pub is_null_keys: ::prost::alloc::vec::Vec<bool>,
    #[prost(int64, optional, tag = "2")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "4")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByCompositeResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_composite_result_items: ::prost::alloc::vec::Vec<
        GroupByCompositeResultItem,
    >,
    #[prost(string, repeated, tag = "2")]
    pub source_group_by_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub next_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByField {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub sort: ::core::option::Option<GroupBySort>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
    #[prost(int64, optional, tag = "6")]
    pub min_doc_count: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(double, optional, tag = "1")]
    pub from: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub to: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByRange {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub ranges: ::prost::alloc::vec::Vec<Range>,
    #[prost(message, optional, tag = "3")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "4")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<Query>,
    #[prost(message, optional, tag = "2")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "3")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoDistance {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub origin: ::core::option::Option<GeoPoint>,
    #[prost(message, repeated, tag = "3")]
    pub ranges: ::prost::alloc::vec::Vec<Range>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoGrid {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// meter
    #[prost(enumeration = "GeoHashPrecision", optional, tag = "2")]
    pub precision: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys: ::core::option::Option<GroupBys>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoGrid {
    #[prost(message, optional, tag = "1")]
    pub top_left: ::core::option::Option<GeoPoint>,
    #[prost(message, optional, tag = "2")]
    pub bottom_right: ::core::option::Option<GeoPoint>,
}
/// single agg result
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvgAggregationResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopRowsAggregationResult {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentilesAggregationItem {
    #[prost(double, optional, tag = "1")]
    pub key: ::core::option::Option<f64>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentilesAggregationResult {
    #[prost(message, repeated, tag = "1")]
    pub percentiles_aggregation_items: ::prost::alloc::vec::Vec<
        PercentilesAggregationItem,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistinctCountAggregationResult {
    #[prost(int64, optional, tag = "1")]
    pub value: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxAggregationResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinAggregationResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumAggregationResult {
    #[prost(double, optional, tag = "1")]
    pub value: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountAggregationResult {
    #[prost(int64, optional, tag = "1")]
    pub value: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationResult {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "AggregationType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    /// encoded by XxxAggregationResult
    #[prost(bytes = "vec", optional, tag = "3")]
    pub agg_result: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationsResult {
    #[prost(message, repeated, tag = "1")]
    pub agg_results: ::prost::alloc::vec::Vec<AggregationResult>,
}
/// group by result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByFieldResultItem {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "4")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByFieldResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_field_result_items: ::prost::alloc::vec::Vec<GroupByFieldResultItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByRangeResultItem {
    #[prost(double, optional, tag = "1")]
    pub from: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub to: ::core::option::Option<f64>,
    #[prost(int64, optional, tag = "3")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByRangeResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_range_result_items: ::prost::alloc::vec::Vec<GroupByRangeResultItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoDistanceResultItem {
    #[prost(double, optional, tag = "1")]
    pub from: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub to: ::core::option::Option<f64>,
    #[prost(int64, optional, tag = "3")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoDistanceResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_geo_distance_result_items: ::prost::alloc::vec::Vec<
        GroupByGeoDistanceResultItem,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByFilterResultItem {
    #[prost(int64, optional, tag = "1")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "3")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByFilterResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_filter_result_items: ::prost::alloc::vec::Vec<GroupByFilterResultItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByResult {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "GroupByType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    /// encoded by XxxGroupByResult
    #[prost(bytes = "vec", optional, tag = "3")]
    pub group_by_result: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBysResult {
    /// sibling pipeline / parallel group bys
    #[prost(message, repeated, tag = "1")]
    pub group_by_results: ::prost::alloc::vec::Vec<GroupByResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByHistogramItem {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "2")]
    pub value: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "4")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByHistogramResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_histogra_items: ::prost::alloc::vec::Vec<GroupByHistogramItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByDateHistogramItem {
    #[prost(int64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "4")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByDateHistogramResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_date_histogram_items: ::prost::alloc::vec::Vec<
        GroupByDateHistogramItem,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoGridResultItem {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub geo_grid: ::core::option::Option<GeoGrid>,
    #[prost(int64, optional, tag = "3")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub sub_aggs_result: ::core::option::Option<AggregationsResult>,
    #[prost(message, optional, tag = "5")]
    pub sub_group_bys_result: ::core::option::Option<GroupBysResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByGeoGridResult {
    #[prost(message, repeated, tag = "1")]
    pub group_by_geo_grid_result_items: ::prost::alloc::vec::Vec<
        GroupByGeoGridResultItem,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub minimum_should_match: ::core::option::Option<i32>,
    #[prost(enumeration = "QueryOperator", optional, tag = "4")]
    pub operator: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchPhraseQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchAllQuery {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub term: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermsQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub terms: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// variant value
    #[prost(bytes = "vec", optional, tag = "2")]
    pub range_from: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// variant value
    #[prost(bytes = "vec", optional, tag = "3")]
    pub range_to: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "4")]
    pub include_lower: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub include_upper: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrefixQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WildcardQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolQuery {
    #[prost(message, repeated, tag = "1")]
    pub must_queries: ::prost::alloc::vec::Vec<Query>,
    #[prost(message, repeated, tag = "2")]
    pub must_not_queries: ::prost::alloc::vec::Vec<Query>,
    #[prost(message, repeated, tag = "3")]
    pub filter_queries: ::prost::alloc::vec::Vec<Query>,
    #[prost(message, repeated, tag = "4")]
    pub should_queries: ::prost::alloc::vec::Vec<Query>,
    #[prost(int32, optional, tag = "5")]
    pub minimum_should_match: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstScoreQuery {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<Query>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldValueFactor {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionScoreQuery {
    #[prost(message, optional, tag = "1")]
    pub query: ::core::option::Option<Query>,
    #[prost(message, optional, tag = "2")]
    pub field_value_factor: ::core::option::Option<FieldValueFactor>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionsScoreQuery {
    #[prost(message, optional, tag = "1")]
    pub query: ::core::option::Option<Query>,
    #[prost(message, repeated, tag = "2")]
    pub functions: ::prost::alloc::vec::Vec<Function>,
    #[prost(enumeration = "FunctionScoreMode", optional, tag = "3")]
    pub score_mode: ::core::option::Option<i32>,
    #[prost(enumeration = "FunctionCombineMode", optional, tag = "4")]
    pub combine_mode: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub min_score: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub max_score: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuffixQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub suffix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "3")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Function {
    #[prost(message, optional, tag = "1")]
    pub field_value_factor: ::core::option::Option<FieldValueFactorFunction>,
    #[prost(message, optional, tag = "2")]
    pub random: ::core::option::Option<RandomScoreFunction>,
    #[prost(message, optional, tag = "3")]
    pub decay: ::core::option::Option<DecayFunction>,
    #[prost(float, optional, tag = "4")]
    pub weight: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "5")]
    pub filter: ::core::option::Option<Query>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldValueFactorFunction {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "2")]
    pub factor: ::core::option::Option<f32>,
    #[prost(enumeration = "FunctionModifier", optional, tag = "3")]
    pub modifier: ::core::option::Option<i32>,
    #[prost(double, optional, tag = "4")]
    pub missing: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecayFunction {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "DecayMathFunction", optional, tag = "2")]
    pub math_function: ::core::option::Option<i32>,
    #[prost(enumeration = "DecayFuncParamType", optional, tag = "3")]
    pub param_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub param: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(double, optional, tag = "5")]
    pub decay: ::core::option::Option<f64>,
    #[prost(enumeration = "MultiValueMode", optional, tag = "6")]
    pub multi_value_mode: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecayFuncDateParam {
    #[prost(int64, optional, tag = "1")]
    pub origin_long: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub origin_string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub scale: ::core::option::Option<DateTimeValue>,
    #[prost(message, optional, tag = "4")]
    pub offset: ::core::option::Option<DateTimeValue>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DecayFuncNumericParam {
    #[prost(double, optional, tag = "1")]
    pub origin: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub scale: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub offset: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecayFuncGeoParam {
    #[prost(string, optional, tag = "1")]
    pub origin: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "2")]
    pub scale: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub offset: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RandomScoreFunction {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedQuery {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<Query>,
    #[prost(enumeration = "ScoreMode", optional, tag = "3")]
    pub score_mode: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub weight: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "5")]
    pub inner_hits: ::core::option::Option<InnerHits>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InnerHits {
    #[prost(message, optional, tag = "1")]
    pub sort: ::core::option::Option<Sort>,
    #[prost(int32, optional, tag = "2")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub limit: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub highlight: ::core::option::Option<Highlight>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoBoundingBoxQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub top_left: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub bottom_right: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoDistanceQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub center_point: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "3")]
    pub distance: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoPolygonQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistsQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KnnVectorQuery {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub top_k: ::core::option::Option<i32>,
    #[prost(float, repeated, packed = "false", tag = "4")]
    pub float32_query_vector: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, optional, tag = "5")]
    pub filter: ::core::option::Option<Query>,
    #[prost(float, optional, tag = "6")]
    pub weight: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub min_score: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "8")]
    pub num_candidates: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(enumeration = "QueryType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub query: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Collapse {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedFilter {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<Query>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScoreSort {
    #[prost(enumeration = "SortOrder", optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrimaryKeySort {
    #[prost(enumeration = "SortOrder", optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldSort {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "SortOrder", optional, tag = "2")]
    pub order: ::core::option::Option<i32>,
    #[prost(enumeration = "SortMode", optional, tag = "3")]
    pub mode: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub nested_filter: ::core::option::Option<NestedFilter>,
    /// encoded as SQLVariant
    #[prost(bytes = "vec", optional, tag = "5")]
    pub missing_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "6")]
    pub missing_field: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DocSort {
    #[prost(enumeration = "SortOrder", optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoDistanceSort {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "SortOrder", optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(enumeration = "SortMode", optional, tag = "4")]
    pub mode: ::core::option::Option<i32>,
    #[prost(enumeration = "GeoDistanceType", optional, tag = "5")]
    pub distance_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub nested_filter: ::core::option::Option<NestedFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sorter {
    #[prost(message, optional, tag = "1")]
    pub field_sort: ::core::option::Option<FieldSort>,
    #[prost(message, optional, tag = "2")]
    pub geo_distance_sort: ::core::option::Option<GeoDistanceSort>,
    #[prost(message, optional, tag = "3")]
    pub score_sort: ::core::option::Option<ScoreSort>,
    #[prost(message, optional, tag = "4")]
    pub pk_sort: ::core::option::Option<PrimaryKeySort>,
    #[prost(message, optional, tag = "5")]
    pub doc_sort: ::core::option::Option<DocSort>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sort {
    #[prost(message, repeated, tag = "1")]
    pub sorter: ::prost::alloc::vec::Vec<Sorter>,
    #[prost(bool, optional, tag = "2")]
    pub disable_default_pk_sorter: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchQuery {
    #[prost(int32, optional, tag = "1")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub limit: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub query: ::core::option::Option<Query>,
    #[prost(message, optional, tag = "5")]
    pub collapse: ::core::option::Option<Collapse>,
    #[prost(message, optional, tag = "6")]
    pub sort: ::core::option::Option<Sort>,
    #[prost(bytes = "vec", optional, tag = "9")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "10")]
    pub aggs: ::core::option::Option<Aggregations>,
    #[prost(message, optional, tag = "11")]
    pub group_bys: ::core::option::Option<GroupBys>,
    #[prost(message, optional, tag = "12")]
    pub highlight: ::core::option::Option<Highlight>,
    #[prost(int32, optional, tag = "13")]
    pub track_total_count: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "14")]
    pub filter: ::core::option::Option<SearchFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFilter {
    #[prost(message, optional, tag = "1")]
    pub query: ::core::option::Option<Query>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Highlight {
    #[prost(message, repeated, tag = "1")]
    pub highlight_parameters: ::prost::alloc::vec::Vec<HighlightParameter>,
    #[prost(
        enumeration = "HighlightEncoder",
        optional,
        tag = "2",
        default = "PlainMode"
    )]
    pub highlight_encoder: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighlightParameter {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub number_of_fragments: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub fragment_size: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub pre_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub post_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "HighlightFragmentOrder",
        optional,
        tag = "6",
        default = "TextSequence"
    )]
    pub fragments_order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnsToGet {
    #[prost(enumeration = "ColumnReturnType", optional, tag = "1")]
    pub return_type: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub column_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub columns_to_get: ::core::option::Option<ColumnsToGet>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub search_query: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub routing_values: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "6")]
    pub timeout_ms: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    #[prost(int64, optional, tag = "1")]
    pub total_hits: ::core::option::Option<i64>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub is_all_succeeded: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "5")]
    pub search_hits: ::prost::alloc::vec::Vec<SearchHit>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub aggs: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub group_bys: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "9")]
    pub consumed: ::core::option::Option<crate::protos::ConsumedCapacity>,
    #[prost(message, optional, tag = "10")]
    pub reserved_consumed: ::core::option::Option<crate::protos::ConsumedCapacity>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchHit {
    #[prost(double, optional, tag = "3")]
    pub score: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "4")]
    pub highlight_result: ::core::option::Option<HighlightResult>,
    #[prost(message, repeated, tag = "5")]
    pub search_inner_hits: ::prost::alloc::vec::Vec<SearchInnerHit>,
    #[prost(int32, optional, tag = "6")]
    pub nested_doc_offset: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInnerHit {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub search_hits: ::prost::alloc::vec::Vec<SearchHit>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighlightResult {
    #[prost(message, repeated, tag = "1")]
    pub highlight_fields: ::prost::alloc::vec::Vec<HighlightField>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighlightField {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub field_fragments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateTimeValue {
    #[prost(int32, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
    #[prost(enumeration = "DateTimeUnit", optional, tag = "2")]
    pub unit: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SingleWordAnalyzerParameter {
    #[prost(bool, optional, tag = "1")]
    pub case_sensitive: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub delimit_word: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitAnalyzerParameter {
    #[prost(string, optional, tag = "1")]
    pub delimiter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub case_sensitive: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FuzzyAnalyzerParameter {
    #[prost(int32, optional, tag = "1")]
    pub min_chars: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub max_chars: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub case_sensitive: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldSchema {
    #[prost(string, optional, tag = "1")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "FieldType", optional, tag = "2")]
    pub field_type: ::core::option::Option<i32>,
    #[prost(enumeration = "IndexOptions", optional, tag = "3")]
    pub index_options: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub analyzer: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub index: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub sort_and_agg: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub store: ::core::option::Option<bool>,
    /// only for nested type
    #[prost(message, repeated, tag = "8")]
    pub field_schemas: ::prost::alloc::vec::Vec<FieldSchema>,
    #[prost(bool, optional, tag = "9")]
    pub is_array: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "10")]
    pub analyzer_parameter: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "11")]
    pub is_virtual_field: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "12")]
    pub source_field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "13")]
    pub date_formats: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "14")]
    pub enable_highlighting: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "15")]
    pub vector_options: ::core::option::Option<VectorOptions>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VectorOptions {
    #[prost(enumeration = "VectorDataType", optional, tag = "1")]
    pub data_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub dimension: ::core::option::Option<i32>,
    #[prost(enumeration = "VectorMetricType", optional, tag = "3")]
    pub metric_type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexSchema {
    #[prost(message, repeated, tag = "1")]
    pub field_schemas: ::prost::alloc::vec::Vec<FieldSchema>,
    #[prost(message, optional, tag = "2")]
    pub index_setting: ::core::option::Option<IndexSetting>,
    #[prost(message, optional, tag = "3")]
    pub index_sort: ::core::option::Option<Sort>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexSetting {
    #[prost(int32, optional, tag = "1")]
    pub number_of_shards: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub routing_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub routing_partition_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSearchIndexRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub index_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub schema: ::core::option::Option<IndexSchema>,
    #[prost(string, optional, tag = "4")]
    pub source_index_name: ::core::option::Option<::prost::alloc::string::String>,
    /// unit is seconds
    #[prost(int32, optional, tag = "5")]
    pub time_to_live: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateSearchIndexResponse {}
/// Update Search Index
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryFlowWeight {
    #[prost(string, optional, tag = "1")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub weight: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSearchIndexRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub switch_index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub query_flow_weight: ::prost::alloc::vec::Vec<QueryFlowWeight>,
    /// unit is seconds
    #[prost(int32, optional, tag = "5")]
    pub time_to_live: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateSearchIndexResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexInfo {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchIndexRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchIndexResponse {
    #[prost(message, repeated, tag = "1")]
    pub indices: ::prost::alloc::vec::Vec<IndexInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSearchIndexRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSearchIndexResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncStat {
    #[prost(enumeration = "SyncPhase", optional, tag = "1")]
    pub sync_phase: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub current_sync_timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MeteringInfo {
    #[prost(int64, optional, tag = "1")]
    pub storage_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub row_count: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub reserved_read_cu: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeSearchIndexRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub include_sync_stat: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeSearchIndexResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<IndexSchema>,
    #[prost(message, optional, tag = "2")]
    pub sync_stat: ::core::option::Option<SyncStat>,
    #[prost(message, optional, tag = "3")]
    pub metering_info: ::core::option::Option<MeteringInfo>,
    #[prost(string, optional, tag = "4")]
    pub brother_index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub query_flow_weight: ::prost::alloc::vec::Vec<QueryFlowWeight>,
    #[prost(int64, optional, tag = "6")]
    pub create_time: ::core::option::Option<i64>,
    /// unit is seconds
    #[prost(int32, optional, tag = "7")]
    pub time_to_live: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "8")]
    pub index_status: ::core::option::Option<IndexStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexStatus {
    #[prost(enumeration = "IndexStatusEnum", optional, tag = "1")]
    pub status: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub status_description: ::core::option::Option<::prost::alloc::string::String>,
}
/// ParallelScan API, same to Search API
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanQuery {
    #[prost(message, optional, tag = "1")]
    pub query: ::core::option::Option<Query>,
    #[prost(int32, optional, tag = "2")]
    pub limit: ::core::option::Option<i32>,
    /// unit is second
    #[prost(int32, optional, tag = "3")]
    pub alive_time: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "5")]
    pub current_parallel_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub max_parallel: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParallelScanRequest {
    #[prost(string, optional, tag = "1")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub columns_to_get: ::core::option::Option<ColumnsToGet>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub session_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "5")]
    pub scan_query: ::core::option::Option<ScanQuery>,
    #[prost(int32, optional, tag = "6")]
    pub timeout_ms: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParallelScanResponse {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// ///////////////////////////////////////////////// old agg proto
///
/// for compatibility
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggType {
    AvgAgg = 1,
    CardinalityAgg = 2,
    MaxAgg = 3,
    MinAgg = 4,
    SumAgg = 5,
    TermsAgg = 6,
    FilterAgg = 7,
    NestedAgg = 8,
    GeoBoundsAgg = 9,
    GeoDistanceAgg = 10,
    StatsAgg = 11,
    ExtendedStatsAgg = 12,
    PercentilesAgg = 13,
    PercentileRanksAgg = 14,
    ValueCountAgg = 15,
}
impl AggType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AvgAgg => "AVG_AGG",
            Self::CardinalityAgg => "CARDINALITY_AGG",
            Self::MaxAgg => "MAX_AGG",
            Self::MinAgg => "MIN_AGG",
            Self::SumAgg => "SUM_AGG",
            Self::TermsAgg => "TERMS_AGG",
            Self::FilterAgg => "FILTER_AGG",
            Self::NestedAgg => "NESTED_AGG",
            Self::GeoBoundsAgg => "GEO_BOUNDS_AGG",
            Self::GeoDistanceAgg => "GEO_DISTANCE_AGG",
            Self::StatsAgg => "STATS_AGG",
            Self::ExtendedStatsAgg => "EXTENDED_STATS_AGG",
            Self::PercentilesAgg => "PERCENTILES_AGG",
            Self::PercentileRanksAgg => "PERCENTILE_RANKS_AGG",
            Self::ValueCountAgg => "VALUE_COUNT_AGG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AVG_AGG" => Some(Self::AvgAgg),
            "CARDINALITY_AGG" => Some(Self::CardinalityAgg),
            "MAX_AGG" => Some(Self::MaxAgg),
            "MIN_AGG" => Some(Self::MinAgg),
            "SUM_AGG" => Some(Self::SumAgg),
            "TERMS_AGG" => Some(Self::TermsAgg),
            "FILTER_AGG" => Some(Self::FilterAgg),
            "NESTED_AGG" => Some(Self::NestedAgg),
            "GEO_BOUNDS_AGG" => Some(Self::GeoBoundsAgg),
            "GEO_DISTANCE_AGG" => Some(Self::GeoDistanceAgg),
            "STATS_AGG" => Some(Self::StatsAgg),
            "EXTENDED_STATS_AGG" => Some(Self::ExtendedStatsAgg),
            "PERCENTILES_AGG" => Some(Self::PercentilesAgg),
            "PERCENTILE_RANKS_AGG" => Some(Self::PercentileRanksAgg),
            "VALUE_COUNT_AGG" => Some(Self::ValueCountAgg),
            _ => None,
        }
    }
}
/// ///////////////////////////////////////////////// new agg proto
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationType {
    AggAvg = 1,
    AggDistinctCount = 6,
    AggMax = 2,
    AggMin = 3,
    AggSum = 4,
    AggCount = 5,
    AggTopRows = 7,
    AggPercentiles = 8,
}
impl AggregationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AggAvg => "AGG_AVG",
            Self::AggDistinctCount => "AGG_DISTINCT_COUNT",
            Self::AggMax => "AGG_MAX",
            Self::AggMin => "AGG_MIN",
            Self::AggSum => "AGG_SUM",
            Self::AggCount => "AGG_COUNT",
            Self::AggTopRows => "AGG_TOP_ROWS",
            Self::AggPercentiles => "AGG_PERCENTILES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGG_AVG" => Some(Self::AggAvg),
            "AGG_DISTINCT_COUNT" => Some(Self::AggDistinctCount),
            "AGG_MAX" => Some(Self::AggMax),
            "AGG_MIN" => Some(Self::AggMin),
            "AGG_SUM" => Some(Self::AggSum),
            "AGG_COUNT" => Some(Self::AggCount),
            "AGG_TOP_ROWS" => Some(Self::AggTopRows),
            "AGG_PERCENTILES" => Some(Self::AggPercentiles),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupByType {
    GroupByField = 1,
    GroupByRange = 2,
    GroupByFilter = 3,
    GroupByGeoDistance = 4,
    GroupByHistogram = 5,
    GroupByDateHistogram = 6,
    GroupByGeoGrid = 7,
    GroupByComposite = 8,
}
impl GroupByType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GroupByField => "GROUP_BY_FIELD",
            Self::GroupByRange => "GROUP_BY_RANGE",
            Self::GroupByFilter => "GROUP_BY_FILTER",
            Self::GroupByGeoDistance => "GROUP_BY_GEO_DISTANCE",
            Self::GroupByHistogram => "GROUP_BY_HISTOGRAM",
            Self::GroupByDateHistogram => "GROUP_BY_DATE_HISTOGRAM",
            Self::GroupByGeoGrid => "GROUP_BY_GEO_GRID",
            Self::GroupByComposite => "GROUP_BY_COMPOSITE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GROUP_BY_FIELD" => Some(Self::GroupByField),
            "GROUP_BY_RANGE" => Some(Self::GroupByRange),
            "GROUP_BY_FILTER" => Some(Self::GroupByFilter),
            "GROUP_BY_GEO_DISTANCE" => Some(Self::GroupByGeoDistance),
            "GROUP_BY_HISTOGRAM" => Some(Self::GroupByHistogram),
            "GROUP_BY_DATE_HISTOGRAM" => Some(Self::GroupByDateHistogram),
            "GROUP_BY_GEO_GRID" => Some(Self::GroupByGeoGrid),
            "GROUP_BY_COMPOSITE" => Some(Self::GroupByComposite),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GeoHashPrecision {
    Ghp5009km4992km1 = 1,
    Ghp1252km624km2 = 2,
    Ghp156km156km3 = 3,
    Ghp39km19km4 = 4,
    Ghp4900m4900m5 = 5,
    Ghp1200m609m6 = 6,
    Ghp152m152m7 = 7,
    Ghp38m19m8 = 8,
    Ghp480cm480cm9 = 9,
    Ghp120cm595mm10 = 10,
    Ghp149mm149mm11 = 11,
    Ghp37mm19mm12 = 12,
}
impl GeoHashPrecision {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ghp5009km4992km1 => "GHP_5009KM_4992KM_1",
            Self::Ghp1252km624km2 => "GHP_1252KM_624KM_2",
            Self::Ghp156km156km3 => "GHP_156KM_156KM_3",
            Self::Ghp39km19km4 => "GHP_39KM_19KM_4",
            Self::Ghp4900m4900m5 => "GHP_4900M_4900M_5",
            Self::Ghp1200m609m6 => "GHP_1200M_609M_6",
            Self::Ghp152m152m7 => "GHP_152M_152M_7",
            Self::Ghp38m19m8 => "GHP_38M_19M_8",
            Self::Ghp480cm480cm9 => "GHP_480CM_480CM_9",
            Self::Ghp120cm595mm10 => "GHP_120CM_595MM_10",
            Self::Ghp149mm149mm11 => "GHP_149MM_149MM_11",
            Self::Ghp37mm19mm12 => "GHP_37MM_19MM_12",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GHP_5009KM_4992KM_1" => Some(Self::Ghp5009km4992km1),
            "GHP_1252KM_624KM_2" => Some(Self::Ghp1252km624km2),
            "GHP_156KM_156KM_3" => Some(Self::Ghp156km156km3),
            "GHP_39KM_19KM_4" => Some(Self::Ghp39km19km4),
            "GHP_4900M_4900M_5" => Some(Self::Ghp4900m4900m5),
            "GHP_1200M_609M_6" => Some(Self::Ghp1200m609m6),
            "GHP_152M_152M_7" => Some(Self::Ghp152m152m7),
            "GHP_38M_19M_8" => Some(Self::Ghp38m19m8),
            "GHP_480CM_480CM_9" => Some(Self::Ghp480cm480cm9),
            "GHP_120CM_595MM_10" => Some(Self::Ghp120cm595mm10),
            "GHP_149MM_149MM_11" => Some(Self::Ghp149mm149mm11),
            "GHP_37MM_19MM_12" => Some(Self::Ghp37mm19mm12),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryType {
    MatchQuery = 1,
    MatchPhraseQuery = 2,
    TermQuery = 3,
    RangeQuery = 4,
    PrefixQuery = 5,
    BoolQuery = 6,
    ConstScoreQuery = 7,
    FunctionScoreQuery = 8,
    NestedQuery = 9,
    WildcardQuery = 10,
    MatchAllQuery = 11,
    GeoBoundingBoxQuery = 12,
    GeoDistanceQuery = 13,
    GeoPolygonQuery = 14,
    TermsQuery = 15,
    ExistsQuery = 16,
    KnnVectorQuery = 17,
    FunctionsScoreQuery = 18,
    SuffixQuery = 19,
}
impl QueryType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MatchQuery => "MATCH_QUERY",
            Self::MatchPhraseQuery => "MATCH_PHRASE_QUERY",
            Self::TermQuery => "TERM_QUERY",
            Self::RangeQuery => "RANGE_QUERY",
            Self::PrefixQuery => "PREFIX_QUERY",
            Self::BoolQuery => "BOOL_QUERY",
            Self::ConstScoreQuery => "CONST_SCORE_QUERY",
            Self::FunctionScoreQuery => "FUNCTION_SCORE_QUERY",
            Self::NestedQuery => "NESTED_QUERY",
            Self::WildcardQuery => "WILDCARD_QUERY",
            Self::MatchAllQuery => "MATCH_ALL_QUERY",
            Self::GeoBoundingBoxQuery => "GEO_BOUNDING_BOX_QUERY",
            Self::GeoDistanceQuery => "GEO_DISTANCE_QUERY",
            Self::GeoPolygonQuery => "GEO_POLYGON_QUERY",
            Self::TermsQuery => "TERMS_QUERY",
            Self::ExistsQuery => "EXISTS_QUERY",
            Self::KnnVectorQuery => "KNN_VECTOR_QUERY",
            Self::FunctionsScoreQuery => "FUNCTIONS_SCORE_QUERY",
            Self::SuffixQuery => "SUFFIX_QUERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_QUERY" => Some(Self::MatchQuery),
            "MATCH_PHRASE_QUERY" => Some(Self::MatchPhraseQuery),
            "TERM_QUERY" => Some(Self::TermQuery),
            "RANGE_QUERY" => Some(Self::RangeQuery),
            "PREFIX_QUERY" => Some(Self::PrefixQuery),
            "BOOL_QUERY" => Some(Self::BoolQuery),
            "CONST_SCORE_QUERY" => Some(Self::ConstScoreQuery),
            "FUNCTION_SCORE_QUERY" => Some(Self::FunctionScoreQuery),
            "NESTED_QUERY" => Some(Self::NestedQuery),
            "WILDCARD_QUERY" => Some(Self::WildcardQuery),
            "MATCH_ALL_QUERY" => Some(Self::MatchAllQuery),
            "GEO_BOUNDING_BOX_QUERY" => Some(Self::GeoBoundingBoxQuery),
            "GEO_DISTANCE_QUERY" => Some(Self::GeoDistanceQuery),
            "GEO_POLYGON_QUERY" => Some(Self::GeoPolygonQuery),
            "TERMS_QUERY" => Some(Self::TermsQuery),
            "EXISTS_QUERY" => Some(Self::ExistsQuery),
            "KNN_VECTOR_QUERY" => Some(Self::KnnVectorQuery),
            "FUNCTIONS_SCORE_QUERY" => Some(Self::FunctionsScoreQuery),
            "SUFFIX_QUERY" => Some(Self::SuffixQuery),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryOperator {
    Or = 1,
    And = 2,
}
impl QueryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Or => "OR",
            Self::And => "AND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OR" => Some(Self::Or),
            "AND" => Some(Self::And),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionModifier {
    FmNone = 1,
    FmLog = 2,
    FmLog1p = 3,
    FmLog2p = 4,
    FmLn = 5,
    FmLn1p = 6,
    FmLn2p = 7,
    FmSquare = 8,
    FmSqrt = 9,
    FmReciprocal = 10,
}
impl FunctionModifier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FmNone => "FM_NONE",
            Self::FmLog => "FM_LOG",
            Self::FmLog1p => "FM_LOG1P",
            Self::FmLog2p => "FM_LOG2P",
            Self::FmLn => "FM_LN",
            Self::FmLn1p => "FM_LN1P",
            Self::FmLn2p => "FM_LN2P",
            Self::FmSquare => "FM_SQUARE",
            Self::FmSqrt => "FM_SQRT",
            Self::FmReciprocal => "FM_RECIPROCAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FM_NONE" => Some(Self::FmNone),
            "FM_LOG" => Some(Self::FmLog),
            "FM_LOG1P" => Some(Self::FmLog1p),
            "FM_LOG2P" => Some(Self::FmLog2p),
            "FM_LN" => Some(Self::FmLn),
            "FM_LN1P" => Some(Self::FmLn1p),
            "FM_LN2P" => Some(Self::FmLn2p),
            "FM_SQUARE" => Some(Self::FmSquare),
            "FM_SQRT" => Some(Self::FmSqrt),
            "FM_RECIPROCAL" => Some(Self::FmReciprocal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DecayFuncParamType {
    DfDateParam = 1,
    DfNumericParam = 2,
    DfGeoParam = 3,
}
impl DecayFuncParamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DfDateParam => "DF_DATE_PARAM",
            Self::DfNumericParam => "DF_NUMERIC_PARAM",
            Self::DfGeoParam => "DF_GEO_PARAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DF_DATE_PARAM" => Some(Self::DfDateParam),
            "DF_NUMERIC_PARAM" => Some(Self::DfNumericParam),
            "DF_GEO_PARAM" => Some(Self::DfGeoParam),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DecayMathFunction {
    Gauss = 1,
    Exp = 2,
    Linear = 3,
}
impl DecayMathFunction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Gauss => "GAUSS",
            Self::Exp => "EXP",
            Self::Linear => "LINEAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GAUSS" => Some(Self::Gauss),
            "EXP" => Some(Self::Exp),
            "LINEAR" => Some(Self::Linear),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultiValueMode {
    MvmMax = 1,
    MvmMin = 2,
    MvmSum = 3,
    MvmAvg = 4,
}
impl MultiValueMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MvmMax => "MVM_MAX",
            Self::MvmMin => "MVM_MIN",
            Self::MvmSum => "MVM_SUM",
            Self::MvmAvg => "MVM_AVG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MVM_MAX" => Some(Self::MvmMax),
            "MVM_MIN" => Some(Self::MvmMin),
            "MVM_SUM" => Some(Self::MvmSum),
            "MVM_AVG" => Some(Self::MvmAvg),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionScoreMode {
    FsmAvg = 1,
    FsmMax = 2,
    FsmSum = 3,
    FsmMin = 4,
    FsmMultiply = 5,
    FsmFirst = 6,
}
impl FunctionScoreMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FsmAvg => "FSM_AVG",
            Self::FsmMax => "FSM_MAX",
            Self::FsmSum => "FSM_SUM",
            Self::FsmMin => "FSM_MIN",
            Self::FsmMultiply => "FSM_MULTIPLY",
            Self::FsmFirst => "FSM_FIRST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FSM_AVG" => Some(Self::FsmAvg),
            "FSM_MAX" => Some(Self::FsmMax),
            "FSM_SUM" => Some(Self::FsmSum),
            "FSM_MIN" => Some(Self::FsmMin),
            "FSM_MULTIPLY" => Some(Self::FsmMultiply),
            "FSM_FIRST" => Some(Self::FsmFirst),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionCombineMode {
    FcmMultiply = 1,
    FcmAvg = 2,
    FcmMax = 3,
    FcmSum = 4,
    FcmMin = 5,
    FcmReplace = 6,
}
impl FunctionCombineMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FcmMultiply => "FCM_MULTIPLY",
            Self::FcmAvg => "FCM_AVG",
            Self::FcmMax => "FCM_MAX",
            Self::FcmSum => "FCM_SUM",
            Self::FcmMin => "FCM_MIN",
            Self::FcmReplace => "FCM_REPLACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FCM_MULTIPLY" => Some(Self::FcmMultiply),
            "FCM_AVG" => Some(Self::FcmAvg),
            "FCM_MAX" => Some(Self::FcmMax),
            "FCM_SUM" => Some(Self::FcmSum),
            "FCM_MIN" => Some(Self::FcmMin),
            "FCM_REPLACE" => Some(Self::FcmReplace),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScoreMode {
    None = 1,
    Avg = 2,
    Max = 3,
    Total = 4,
    Min = 5,
}
impl ScoreMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SCORE_MODE_NONE",
            Self::Avg => "SCORE_MODE_AVG",
            Self::Max => "SCORE_MODE_MAX",
            Self::Total => "SCORE_MODE_TOTAL",
            Self::Min => "SCORE_MODE_MIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCORE_MODE_NONE" => Some(Self::None),
            "SCORE_MODE_AVG" => Some(Self::Avg),
            "SCORE_MODE_MAX" => Some(Self::Max),
            "SCORE_MODE_TOTAL" => Some(Self::Total),
            "SCORE_MODE_MIN" => Some(Self::Min),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortOrder {
    Asc = 0,
    Desc = 1,
}
impl SortOrder {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Asc => "SORT_ORDER_ASC",
            Self::Desc => "SORT_ORDER_DESC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_ORDER_ASC" => Some(Self::Asc),
            "SORT_ORDER_DESC" => Some(Self::Desc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortMode {
    Min = 0,
    Max = 1,
    Avg = 2,
}
impl SortMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Min => "SORT_MODE_MIN",
            Self::Max => "SORT_MODE_MAX",
            Self::Avg => "SORT_MODE_AVG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_MODE_MIN" => Some(Self::Min),
            "SORT_MODE_MAX" => Some(Self::Max),
            "SORT_MODE_AVG" => Some(Self::Avg),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GeoDistanceType {
    GeoDistanceArc = 0,
    GeoDistancePlane = 1,
}
impl GeoDistanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GeoDistanceArc => "GEO_DISTANCE_ARC",
            Self::GeoDistancePlane => "GEO_DISTANCE_PLANE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GEO_DISTANCE_ARC" => Some(Self::GeoDistanceArc),
            "GEO_DISTANCE_PLANE" => Some(Self::GeoDistancePlane),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HighlightFragmentOrder {
    TextSequence = 1,
    Score = 2,
}
impl HighlightFragmentOrder {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TextSequence => "TEXT_SEQUENCE",
            Self::Score => "SCORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEXT_SEQUENCE" => Some(Self::TextSequence),
            "SCORE" => Some(Self::Score),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HighlightEncoder {
    PlainMode = 1,
    HtmlMode = 2,
}
impl HighlightEncoder {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PlainMode => "PLAIN_MODE",
            Self::HtmlMode => "HTML_MODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAIN_MODE" => Some(Self::PlainMode),
            "HTML_MODE" => Some(Self::HtmlMode),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnReturnType {
    ReturnAll = 1,
    ReturnSpecified = 2,
    ReturnNone = 3,
    ReturnAllFromIndex = 4,
}
impl ColumnReturnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReturnAll => "RETURN_ALL",
            Self::ReturnSpecified => "RETURN_SPECIFIED",
            Self::ReturnNone => "RETURN_NONE",
            Self::ReturnAllFromIndex => "RETURN_ALL_FROM_INDEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RETURN_ALL" => Some(Self::ReturnAll),
            "RETURN_SPECIFIED" => Some(Self::ReturnSpecified),
            "RETURN_NONE" => Some(Self::ReturnNone),
            "RETURN_ALL_FROM_INDEX" => Some(Self::ReturnAllFromIndex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexOptions {
    Docs = 1,
    Freqs = 2,
    Positions = 3,
    Offsets = 4,
}
impl IndexOptions {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Docs => "DOCS",
            Self::Freqs => "FREQS",
            Self::Positions => "POSITIONS",
            Self::Offsets => "OFFSETS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOCS" => Some(Self::Docs),
            "FREQS" => Some(Self::Freqs),
            "POSITIONS" => Some(Self::Positions),
            "OFFSETS" => Some(Self::Offsets),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldType {
    Long = 1,
    Double = 2,
    Boolean = 3,
    Keyword = 4,
    Text = 5,
    Nested = 6,
    GeoPoint = 7,
    Date = 8,
    Vector = 9,
    FuzzyKeyword = 10,
}
impl FieldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Long => "LONG",
            Self::Double => "DOUBLE",
            Self::Boolean => "BOOLEAN",
            Self::Keyword => "KEYWORD",
            Self::Text => "TEXT",
            Self::Nested => "NESTED",
            Self::GeoPoint => "GEO_POINT",
            Self::Date => "DATE",
            Self::Vector => "VECTOR",
            Self::FuzzyKeyword => "FUZZY_KEYWORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LONG" => Some(Self::Long),
            "DOUBLE" => Some(Self::Double),
            "BOOLEAN" => Some(Self::Boolean),
            "KEYWORD" => Some(Self::Keyword),
            "TEXT" => Some(Self::Text),
            "NESTED" => Some(Self::Nested),
            "GEO_POINT" => Some(Self::GeoPoint),
            "DATE" => Some(Self::Date),
            "VECTOR" => Some(Self::Vector),
            "FUZZY_KEYWORD" => Some(Self::FuzzyKeyword),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DateTimeUnit {
    Year = 1,
    /// 一个季度
    QuarterYear = 2,
    Month = 3,
    Week = 4,
    Day = 5,
    Hour = 6,
    Minute = 7,
    Second = 8,
    Millisecond = 9,
}
impl DateTimeUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Year => "YEAR",
            Self::QuarterYear => "QUARTER_YEAR",
            Self::Month => "MONTH",
            Self::Week => "WEEK",
            Self::Day => "DAY",
            Self::Hour => "HOUR",
            Self::Minute => "MINUTE",
            Self::Second => "SECOND",
            Self::Millisecond => "MILLISECOND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "YEAR" => Some(Self::Year),
            "QUARTER_YEAR" => Some(Self::QuarterYear),
            "MONTH" => Some(Self::Month),
            "WEEK" => Some(Self::Week),
            "DAY" => Some(Self::Day),
            "HOUR" => Some(Self::Hour),
            "MINUTE" => Some(Self::Minute),
            "SECOND" => Some(Self::Second),
            "MILLISECOND" => Some(Self::Millisecond),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VectorDataType {
    VdFloat32 = 2,
}
impl VectorDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VdFloat32 => "VD_FLOAT_32",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VD_FLOAT_32" => Some(Self::VdFloat32),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VectorMetricType {
    VmEuclidean = 0,
    VmCosine = 1,
    VmDotProduct = 2,
}
impl VectorMetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VmEuclidean => "VM_EUCLIDEAN",
            Self::VmCosine => "VM_COSINE",
            Self::VmDotProduct => "VM_DOT_PRODUCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VM_EUCLIDEAN" => Some(Self::VmEuclidean),
            "VM_COSINE" => Some(Self::VmCosine),
            "VM_DOT_PRODUCT" => Some(Self::VmDotProduct),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncPhase {
    Full = 1,
    Incr = 2,
}
impl SyncPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Full => "FULL",
            Self::Incr => "INCR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FULL" => Some(Self::Full),
            "INCR" => Some(Self::Incr),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexStatusEnum {
    Pending = 1,
    Failed = 2,
    Running = 3,
}
impl IndexStatusEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Pending => "PENDING",
            Self::Failed => "FAILED",
            Self::Running => "RUNNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING" => Some(Self::Pending),
            "FAILED" => Some(Self::Failed),
            "RUNNING" => Some(Self::Running),
            _ => None,
        }
    }
}
