// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeseriesTableOptions {
    #[prost(int32, optional, tag = "1")]
    pub time_to_live: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeseriesMetaOptions {
    #[prost(bool, optional, tag = "1")]
    pub allow_update_attributes: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub meta_time_to_live: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesTableMeta {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub table_options: ::core::option::Option<TimeseriesTableOptions>,
    #[prost(string, optional, tag = "3")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub meta_options: ::core::option::Option<TimeseriesMetaOptions>,
    #[prost(string, repeated, tag = "5")]
    pub timeseries_key_schema: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "6")]
    pub field_primary_key_schema: ::prost::alloc::vec::Vec<
        crate::protos::PrimaryKeySchema,
    >,
    #[prost(bool, optional, tag = "7")]
    pub disable_hash_partition_key: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub disable_timeseries_meta_index: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LastpointIndexMetaForCreate {
    #[prost(string, required, tag = "1")]
    pub index_table_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesTableRequest {
    #[prost(message, required, tag = "1")]
    pub table_meta: TimeseriesTableMeta,
    #[prost(message, repeated, tag = "3")]
    pub analytical_stores: ::prost::alloc::vec::Vec<TimeseriesAnalyticalStore>,
    #[prost(bool, optional, tag = "4")]
    pub enable_analytical_store: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "5")]
    pub lastpoint_index_metas: ::prost::alloc::vec::Vec<LastpointIndexMetaForCreate>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesTableResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTimeseriesTableRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTimeseriesTableResponse {
    #[prost(message, repeated, tag = "1")]
    pub table_metas: ::prost::alloc::vec::Vec<TimeseriesTableMeta>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesTableResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub table_options: ::core::option::Option<TimeseriesTableOptions>,
    #[prost(message, optional, tag = "3")]
    pub meta_options: ::core::option::Option<TimeseriesMetaOptions>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesTableResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTimeseriesTableRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTimeseriesTableResponse {
    #[prost(message, required, tag = "1")]
    pub table_meta: TimeseriesTableMeta,
    #[prost(message, repeated, tag = "2")]
    pub analytical_stores: ::prost::alloc::vec::Vec<TimeseriesAnalyticalStore>,
    #[prost(message, repeated, tag = "3")]
    pub lastpoint_indexes: ::prost::alloc::vec::Vec<TimeseriesLastpointIndex>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQueryCondition {
    #[prost(enumeration = "MetaQueryConditionType", required, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub proto_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQueryCompositeCondition {
    #[prost(enumeration = "MetaQueryCompositeOperator", required, tag = "1")]
    pub op: i32,
    #[prost(message, repeated, tag = "2")]
    pub sub_conditions: ::prost::alloc::vec::Vec<MetaQueryCondition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQueryMeasurementCondition {
    #[prost(enumeration = "MetaQuerySingleOperator", required, tag = "1")]
    pub op: i32,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQuerySourceCondition {
    #[prost(enumeration = "MetaQuerySingleOperator", required, tag = "1")]
    pub op: i32,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQueryTagCondition {
    #[prost(enumeration = "MetaQuerySingleOperator", required, tag = "1")]
    pub op: i32,
    #[prost(string, required, tag = "2")]
    pub tag_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaQueryAttributeCondition {
    #[prost(enumeration = "MetaQuerySingleOperator", required, tag = "1")]
    pub op: i32,
    #[prost(string, required, tag = "2")]
    pub attr_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetaQueryUpdateTimeCondition {
    #[prost(enumeration = "MetaQuerySingleOperator", required, tag = "1")]
    pub op: i32,
    #[prost(int64, required, tag = "2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesTag {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesKey {
    #[prost(string, optional, tag = "1")]
    pub measurement: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub tags: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub tag_list: ::prost::alloc::vec::Vec<TimeseriesTag>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesMeta {
    #[prost(message, required, tag = "1")]
    pub time_series_key: TimeseriesKey,
    #[prost(string, optional, tag = "2")]
    pub attributes: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub update_time: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTimeseriesMetaRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub condition: ::core::option::Option<MetaQueryCondition>,
    #[prost(bool, optional, tag = "3")]
    pub get_total_hit: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "5")]
    pub limit: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTimeseriesMetaResponse {
    #[prost(message, repeated, tag = "1")]
    pub timeseries_metas: ::prost::alloc::vec::Vec<TimeseriesMeta>,
    #[prost(int64, optional, tag = "2")]
    pub total_hit: ::core::option::Option<i64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesRows {
    #[prost(enumeration = "RowsSerializeType", required, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub rows_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, optional, tag = "3")]
    pub flatbuffer_crc32c: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutTimeseriesDataRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, required, tag = "2")]
    pub rows_data: TimeseriesRows,
    #[prost(enumeration = "MetaUpdateMode", optional, tag = "3")]
    pub meta_update_mode: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailedRowInfo {
    #[prost(int32, required, tag = "1")]
    pub row_index: i32,
    #[prost(string, optional, tag = "2")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaUpdateStatus {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub row_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub meta_update_times: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutTimeseriesDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub failed_rows: ::prost::alloc::vec::Vec<FailedRowInfo>,
    #[prost(message, optional, tag = "2")]
    pub meta_update_status: ::core::option::Option<MetaUpdateStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesFieldsToGet {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTimeseriesDataRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, required, tag = "2")]
    pub time_series_key: TimeseriesKey,
    #[prost(int64, optional, tag = "3")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub specific_time: ::core::option::Option<i64>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "7")]
    pub limit: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "8")]
    pub backward: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "9")]
    pub fields_to_get: ::prost::alloc::vec::Vec<TimeseriesFieldsToGet>,
    #[prost(int64, optional, tag = "10")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTimeseriesDataResponse {
    #[prost(bytes = "vec", required, tag = "1")]
    pub rows_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesMetaRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub timeseries_meta: ::prost::alloc::vec::Vec<TimeseriesMeta>,
    #[prost(int64, optional, tag = "3")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesMetaResponse {
    #[prost(message, repeated, tag = "1")]
    pub failed_rows: ::prost::alloc::vec::Vec<FailedRowInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesMetaRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub timeseries_key: ::prost::alloc::vec::Vec<TimeseriesKey>,
    #[prost(int64, optional, tag = "3")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesMetaResponse {
    #[prost(message, repeated, tag = "1")]
    pub failed_rows: ::prost::alloc::vec::Vec<FailedRowInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitTimeseriesScanTaskRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub measurement_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, required, tag = "3")]
    pub split_count_hint: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitTimeseriesScanTaskResponse {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub split_infos: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanTimeseriesDataRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub split_info: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "3")]
    pub start_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub end_time_us: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "5")]
    pub fields_to_get: ::prost::alloc::vec::Vec<TimeseriesFieldsToGet>,
    #[prost(int32, optional, tag = "6")]
    pub limit: ::core::option::Option<i32>,
    #[prost(enumeration = "RowsSerializeType", optional, tag = "7")]
    pub data_serialize_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "9")]
    pub supported_table_version: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanTimeseriesDataResponse {
    #[prost(enumeration = "RowsSerializeType", optional, tag = "1")]
    pub data_serialize_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", required, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub next_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesAnalyticalStore {
    /// 存储名称
    #[prost(string, optional, tag = "1")]
    pub store_name: ::core::option::Option<::prost::alloc::string::String>,
    /// 存储数据TTL
    #[prost(int32, optional, tag = "2")]
    pub time_to_live: ::core::option::Option<i32>,
    /// 全量或者增量构建
    #[prost(enumeration = "AnalyticalStoreSyncType", optional, tag = "3")]
    pub sync_option: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalyticalStoreSyncStat {
    /// 构建状态
    #[prost(enumeration = "AnalyticalStoreSyncType", optional, tag = "1")]
    pub sync_phase: ::core::option::Option<i32>,
    /// 最新同步时间
    #[prost(int64, optional, tag = "2")]
    pub current_sync_timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalyticalStoreStorageSize {
    /// 分析存储占用存储大小
    #[prost(int64, optional, tag = "1")]
    pub size: ::core::option::Option<i64>,
    /// 统计时间
    #[prost(int64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesAnalyticalStoreRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    /// 需要创建的时序分析存储
    #[prost(message, optional, tag = "2")]
    pub analytical_store: ::core::option::Option<TimeseriesAnalyticalStore>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesAnalyticalStoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesAnalyticalStoreRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub store_name: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "3")]
    pub drop_mapping_table: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesAnalyticalStoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTimeseriesAnalyticalStoreRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub store_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTimeseriesAnalyticalStoreResponse {
    #[prost(message, optional, tag = "1")]
    pub analytical_store: ::core::option::Option<TimeseriesAnalyticalStore>,
    #[prost(message, optional, tag = "2")]
    pub sync_stat: ::core::option::Option<AnalyticalStoreSyncStat>,
    #[prost(message, optional, tag = "3")]
    pub storage_size: ::core::option::Option<AnalyticalStoreStorageSize>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesAnalyticalStoreRequest {
    #[prost(string, required, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(message, required, tag = "2")]
    pub analytical_store: TimeseriesAnalyticalStore,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTimeseriesAnalyticalStoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesLastpointIndex {
    #[prost(string, optional, tag = "1")]
    pub index_table_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesLastpointIndexRequest {
    #[prost(string, required, tag = "1")]
    pub main_table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub index_table_name: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "3")]
    pub include_base_data: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub create_on_wide_column_table: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "5")]
    pub index_primary_key_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTimeseriesLastpointIndexResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesLastpointIndexRequest {
    #[prost(string, required, tag = "1")]
    pub main_table_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub index_table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTimeseriesLastpointIndexResponse {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaQueryConditionType {
    CompositeCondition = 1,
    MeasurementCondition = 2,
    SourceCondition = 3,
    TagCondition = 4,
    UpdateTimeCondition = 5,
    AttributeCondition = 6,
}
impl MetaQueryConditionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CompositeCondition => "COMPOSITE_CONDITION",
            Self::MeasurementCondition => "MEASUREMENT_CONDITION",
            Self::SourceCondition => "SOURCE_CONDITION",
            Self::TagCondition => "TAG_CONDITION",
            Self::UpdateTimeCondition => "UPDATE_TIME_CONDITION",
            Self::AttributeCondition => "ATTRIBUTE_CONDITION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPOSITE_CONDITION" => Some(Self::CompositeCondition),
            "MEASUREMENT_CONDITION" => Some(Self::MeasurementCondition),
            "SOURCE_CONDITION" => Some(Self::SourceCondition),
            "TAG_CONDITION" => Some(Self::TagCondition),
            "UPDATE_TIME_CONDITION" => Some(Self::UpdateTimeCondition),
            "ATTRIBUTE_CONDITION" => Some(Self::AttributeCondition),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaQueryCompositeOperator {
    OpAnd = 1,
    OpOr = 2,
    OpNot = 3,
}
impl MetaQueryCompositeOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OpAnd => "OP_AND",
            Self::OpOr => "OP_OR",
            Self::OpNot => "OP_NOT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OP_AND" => Some(Self::OpAnd),
            "OP_OR" => Some(Self::OpOr),
            "OP_NOT" => Some(Self::OpNot),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaQuerySingleOperator {
    OpEqual = 1,
    OpGreaterThan = 2,
    OpGreaterEqual = 3,
    OpLessThan = 4,
    OpLessEqual = 5,
    OpPrefix = 6,
}
impl MetaQuerySingleOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OpEqual => "OP_EQUAL",
            Self::OpGreaterThan => "OP_GREATER_THAN",
            Self::OpGreaterEqual => "OP_GREATER_EQUAL",
            Self::OpLessThan => "OP_LESS_THAN",
            Self::OpLessEqual => "OP_LESS_EQUAL",
            Self::OpPrefix => "OP_PREFIX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OP_EQUAL" => Some(Self::OpEqual),
            "OP_GREATER_THAN" => Some(Self::OpGreaterThan),
            "OP_GREATER_EQUAL" => Some(Self::OpGreaterEqual),
            "OP_LESS_THAN" => Some(Self::OpLessThan),
            "OP_LESS_EQUAL" => Some(Self::OpLessEqual),
            "OP_PREFIX" => Some(Self::OpPrefix),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowsSerializeType {
    RstFlatBuffer = 0,
    RstPlainBuffer = 1,
}
impl RowsSerializeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RstFlatBuffer => "RST_FLAT_BUFFER",
            Self::RstPlainBuffer => "RST_PLAIN_BUFFER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RST_FLAT_BUFFER" => Some(Self::RstFlatBuffer),
            "RST_PLAIN_BUFFER" => Some(Self::RstPlainBuffer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaUpdateMode {
    MumNormal = 0,
    MumIgnore = 1,
}
impl MetaUpdateMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MumNormal => "MUM_NORMAL",
            Self::MumIgnore => "MUM_IGNORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MUM_NORMAL" => Some(Self::MumNormal),
            "MUM_IGNORE" => Some(Self::MumIgnore),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnalyticalStoreSyncType {
    /// 全量构建
    SyncTypeFull = 1,
    /// 增量构建
    SyncTypeIncr = 2,
}
impl AnalyticalStoreSyncType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SyncTypeFull => "SYNC_TYPE_FULL",
            Self::SyncTypeIncr => "SYNC_TYPE_INCR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYNC_TYPE_FULL" => Some(Self::SyncTypeFull),
            "SYNC_TYPE_INCR" => Some(Self::SyncTypeIncr),
            _ => None,
        }
    }
}
